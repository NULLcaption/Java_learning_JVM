## 类文件结构

### 	一、Class类文件结构

#### 	Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。

#### 	Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。

​	无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
​	表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由表6-1所示的数据项构成。

### 	二、常量池

#### 	Class文件之中的资源仓库

#### 	存放两大类常量：

​		1、字面量：Java语言层面的常量概念，如文本字符串、声明为final的常量值等；

​		2、符号引用：编译原理方面的概念；主要包含三种常量：类和接口的全限定名；字段的名称和描述符；方法的名称和描述符；

### 	三、访问标志

### 	标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

​	<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201026154306270.png" alt="image-20201026154306270" style="zoom: 67%;" />

### 	四、类索引、父类索引与接口索引集合

#### 	类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。

### 	五、字段表集合

#### 	用于描述接口或者类中声明的变量；

### 	六、方法表集合

#### 	Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集（attributes）。

### 	七、属性表集合

#### 	描述某些场景专有的信息。

## 虚拟机类加载机制

### 一、类加载的时机

#### 	类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201026160152200.png" alt="image-20201026160152200" style="zoom: 67%;" />

### 二、类加载的过程

##### 	1、加载

​	1）通过一个类的全限定名来获取定义此类的二进制字节流。

​	2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

​	3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

### 	2、验证

​	目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

​	主要有四个阶段的验证：文件格式验证、元数据验证、字节码验证、符号引用验证。

### 	3、准备

​	准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

### 	4、解析

​	虚拟机将常量池内的符号引用替换为直接引用的过程；

##### 	5、初始化

​	初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。

### 	三、类加载器

### 	1、	类与类加载器

​	对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。比如：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

### 	2、双亲委派模型

​	Java虚拟机的角度来讲，只存在两种不同的类加载器：

​	一种是启动类加载器（Bootstrap  ClassLoader），这个类加载器使用C++语言实现 [1] ，是虚拟机自身的一部分；

​	另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201026161836386.png" alt="image-20201026161836386" style="zoom:67%;" />

​	如图所示，双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

## 虚拟机字节码执行引擎



## 类加载及执行子系统的案例与实战

